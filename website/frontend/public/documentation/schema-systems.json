{
  "id": "schema-systems",
  "title": "Schema Systems - Structured Output",
  "description": "Ensure LLM outputs match expected structure using Pydantic, RAIL, or JSON Schema",
  "content": [
    {
      "type": "text",
      "content": "**Schema Systems** ensure LLM outputs match expected structure using Pydantic, RAIL, or JSON Schema. This guarantees that LLM responses are in the exact format your application expects, making integration seamless and reliable."
    },
    {
      "type": "section",
      "title": "Understanding Schema Systems",
      "subsections": [
        {
          "title": "What are Schema Systems?",
          "type": "text",
          "content": "Schema Systems define the expected structure of LLM outputs. Instead of accepting free-form text, you specify:\n\n- **Fields**: What fields should be in the output\n- **Types**: What types each field should be (string, int, list, etc.)\n- **Validation**: Rules for validating each field\n- **Required/Optional**: Which fields are required vs optional\n\n**Benefits**:\n- **Type Safety**: Guaranteed structure and types\n- **Validation**: Automatic validation of structure\n- **Integration**: Easy integration with your application\n- **Error Handling**: Clear errors when structure doesn't match"
        },
        {
          "title": "Why Use Schema Systems?",
          "type": "list",
          "items": [
            "**Structured Data Extraction**: Extract entities from unstructured text",
            "**API Responses**: Ensure consistent API response format",
            "**Data Pipelines**: Guarantee structure for downstream processing",
            "**Type Safety**: Catch type errors early",
            "**Integration**: Easy integration with typed systems"
          ]
        }
      ]
    },
    {
      "type": "section",
      "title": "Pydantic Schema - Python-First Approach",
      "subsections": [
        {
          "title": "What is Pydantic?",
          "type": "text",
          "content": "Pydantic is a Python library for data validation using Python type annotations. It's the most Pythonic way to define schemas in Wall Library.\n\n**Advantages**:\n- **Python-native**: Uses Python classes and type hints\n- **Type-safe**: Full type checking\n- **Automatic validation**: Validates types automatically\n- **Rich validation**: Field validators, custom validators\n- **Easy to use**: Familiar Python syntax"
        },
        {
          "title": "Step-by-Step Pydantic Setup",
          "type": "code",
          "code": "from wall_library import WallGuard\nfrom pydantic import BaseModel, Field\nfrom typing import List, Optional\n\n# Step 1: Define your Pydantic model\nclass PatientInfo(BaseModel):\n    \"\"\"Patient information schema.\"\"\"\n    condition: str = Field(\n        description=\"Medical condition or diagnosis\",\n        min_length=3,\n        max_length=100\n    )\n    symptoms: List[str] = Field(\n        description=\"List of symptoms\",\n        min_items=1,\n        max_items=10\n    )\n    severity: str = Field(\n        description=\"Severity level: mild, moderate, or severe\",\n        pattern=\"^(mild|moderate|severe)$\"\n    )\n    recommendation: str = Field(\n        description=\"Recommended action\",\n        min_length=10\n    )\n    age: Optional[int] = Field(\n        description=\"Patient age\",\n        ge=0,\n        le=150,\n        default=None\n    )\n\n# Step 2: Create guard from Pydantic model\nguard = WallGuard.for_pydantic(\n    output_class=PatientInfo,\n    prompt=\"Extract patient information from the following text:\"\n)\n\n# Step 3: Use with LLM\nfrom openai import OpenAI\nclient = OpenAI(api_key=\"your-api-key\")\n\ndef llm_api_call(prompt: str, **kwargs):\n    response = client.chat.completions.create(\n        model=\"gpt-3.5-turbo\",\n        messages=[{\"role\": \"user\", \"content\": prompt}],\n        **kwargs\n    )\n    return response.choices[0].message.content\n\n# Step 4: Call guard (automatically validates structure)\nraw, validated, outcome = guard(\n    llm_api=llm_api_call,\n    prompt=\"Patient has diabetes with symptoms of increased thirst and frequent urination. Age 45. Severity: moderate.\"\n)\n\n# Step 5: Use validated output (guaranteed structure)\nif outcome.validation_passed:\n    patient = validated  # This is a dict matching PatientInfo structure\n    print(f\"Condition: {patient['condition']}\")\n    print(f\"Symptoms: {patient['symptoms']}\")\n    print(f\"Severity: {patient['severity']}\")\n    print(f\"Age: {patient.get('age')}\")\nelse:\n    print(f\"Validation failed: {outcome.error_messages}\")",
          "input": "Using Pydantic schema...",
          "output": "Condition: diabetes\nSymptoms: ['increased thirst', 'frequent urination']\nSeverity: moderate\nAge: 45"
        },
        {
          "title": "Advanced Pydantic Features",
          "type": "code",
          "code": "from pydantic import BaseModel, Field, validator\nfrom typing import List, Optional\nfrom datetime import datetime\n\nclass AdvancedPatientInfo(BaseModel):\n    \"\"\"Advanced patient info with custom validation.\"\"\"\n    \n    condition: str = Field(..., description=\"Medical condition\")\n    symptoms: List[str] = Field(..., description=\"List of symptoms\")\n    \n    # Custom validator\n    @validator('symptoms')\n    def validate_symptoms(cls, v):\n        if len(v) < 1:\n            raise ValueError('Must have at least one symptom')\n        if len(v) > 20:\n            raise ValueError('Too many symptoms (max 20)')\n        return v\n    \n    # Optional field with default\n    created_at: Optional[datetime] = Field(default_factory=datetime.now)\n    \n    # Nested model\n    class ContactInfo(BaseModel):\n        email: str = Field(..., description=\"Email address\")\n        phone: Optional[str] = Field(None, description=\"Phone number\")\n    \n    contact: Optional[ContactInfo] = None\n\n# Use nested model\nguard = WallGuard.for_pydantic(output_class=AdvancedPatientInfo)\n\n# LLM output is validated against nested structure\nraw, validated, outcome = guard(llm_api=llm_call, prompt=\"...\")\n\n# Access nested fields\nif outcome.validation_passed:\n    contact = validated.get('contact')\n    if contact:\n        print(f\"Email: {contact['email']}\")",
          "input": "Using advanced Pydantic...",
          "output": "✅ Advanced schema validated"
        }
      ]
    },
    {
      "type": "section",
      "title": "RAIL Schema - XML-Based Approach",
      "subsections": [
        {
          "title": "What is RAIL?",
          "type": "text",
          "content": "RAIL (Reliable AI Language) is an XML-based schema definition language. It's more verbose than Pydantic but provides fine-grained control over validation.\n\n**Advantages**:\n- **Fine-grained control**: Validators per field\n- **On-fail actions**: Different actions per field\n- **Prompt integration**: Includes prompt in schema\n- **XML-based**: Familiar to XML users"
        },
        {
          "title": "RAIL Schema Example",
          "type": "code",
          "code": "from wall_library import WallGuard\nfrom wall_library.schema.rail_schema import rail_string_to_schema\n\n# Define RAIL schema as string\nrail_schema = \"\"\"\n<rail version=\"0.1\">\n<output>\n    <string name=\"symptom_description\" \n            description=\"Patient symptom description\" \n            validators=\"length\" \n            on-fail-length=\"exception\"/>\n    <string name=\"recommendation\" \n            description=\"General health recommendation\" \n            validators=\"length\" \n            on-fail-length=\"exception\"/>\n    <integer name=\"severity_score\" \n             description=\"Severity score from 1-10\" \n             validators=\"range\" \n             on-fail-range=\"exception\"/>\n</output>\n<prompt>\nYou are a healthcare assistant. Provide symptom information and recommendations.\nExtract the following information from the patient description:\n- Symptom description\n- Recommendation\n- Severity score (1-10)\n</prompt>\n</rail>\n\"\"\"\n\n# Parse RAIL schema\nprocessed_schema = rail_string_to_schema(rail_schema)\n\n# Create guard with RAIL schema\nguard = WallGuard()\nguard.processed_schema = processed_schema\n\n# Use guard\nraw, validated, outcome = guard(llm_api=llm_call, prompt=\"Patient has diabetes symptoms\")\n\nif outcome.validation_passed:\n    print(f\"Symptom: {validated['symptom_description']}\")\n    print(f\"Recommendation: {validated['recommendation']}\")\n    print(f\"Severity: {validated['severity_score']}\")",
          "input": "Using RAIL schema...",
          "output": "✅ RAIL schema validated"
        },
        {
          "title": "Loading RAIL from File",
          "type": "code",
          "code": "from wall_library import WallGuard\n\n# Load RAIL schema from file\nguard = WallGuard.for_rail(\"schema.rail\")\n\n# Or use RAIL string\nguard = WallGuard.for_rail_string(rail_schema_string)\n\n# Guard is now configured with RAIL schema",
          "input": "Loading RAIL from file...",
          "output": "✅ RAIL schema loaded"
        }
      ]
    },
    {
      "type": "section",
      "title": "JSON Schema - Standard Format",
      "subsections": [
        {
          "title": "What is JSON Schema?",
          "type": "text",
          "content": "JSON Schema is a standard format for describing JSON structures. It's widely supported and language-agnostic.\n\n**Advantages**:\n- **Standard format**: Widely supported\n- **Language-agnostic**: Works with any language\n- **Rich validation**: Comprehensive validation rules\n- **Tool support**: Many tools support JSON Schema"
        },
        {
          "title": "JSON Schema Example",
          "type": "code",
          "code": "from wall_library import WallGuard\nfrom wall_library.schema.json_schema import json_schema_to_processed\n\n# Define JSON Schema\njson_schema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"condition\": {\n            \"type\": \"string\",\n            \"description\": \"Medical condition\",\n            \"minLength\": 3,\n            \"maxLength\": 100\n        },\n        \"symptoms\": {\n            \"type\": \"array\",\n            \"items\": {\"type\": \"string\"},\n            \"minItems\": 1,\n            \"maxItems\": 10\n        },\n        \"severity\": {\n            \"type\": \"string\",\n            \"enum\": [\"mild\", \"moderate\", \"severe\"]\n        }\n    },\n    \"required\": [\"condition\", \"symptoms\", \"severity\"]\n}\n\n# Convert to processed schema\nprocessed_schema = json_schema_to_processed(json_schema)\n\n# Create guard\nguard = WallGuard()\nguard.processed_schema = processed_schema\n\n# Use guard\nraw, validated, outcome = guard(llm_api=llm_call, prompt=\"...\")\n\nif outcome.validation_passed:\n    print(f\"Validated: {validated}\")",
          "input": "Using JSON Schema...",
          "output": "✅ JSON Schema validated"
        }
      ]
    },
    {
      "type": "section",
      "title": "Choosing the Right Schema Type",
      "subsections": [
        {
          "title": "When to Use Pydantic",
          "type": "list",
          "items": [
            "Python applications (native Python support)",
            "Type safety is important",
            "You want Python classes",
            "You need custom validators",
            "You prefer Python syntax"
          ]
        },
        {
          "title": "When to Use RAIL",
          "type": "list",
          "items": [
            "You need fine-grained field-level control",
            "You want different on-fail actions per field",
            "You prefer XML-based definitions",
            "You need prompt integration in schema"
          ]
        },
        {
          "title": "When to Use JSON Schema",
          "type": "list",
          "items": [
            "Multi-language applications",
            "You need standard format",
            "You're integrating with other systems",
            "You have existing JSON Schema definitions"
          ]
        }
      ]
    },
    {
      "type": "section",
      "title": "Best Practices",
      "subsections": [
        {
          "title": "Recommendations",
          "type": "list",
          "items": [
            "**Use Pydantic for Python**: Most Pythonic and type-safe",
            "**Provide descriptions**: Help LLM understand what each field means",
            "**Set appropriate constraints**: min_length, max_length, patterns, etc.",
            "**Use optional fields**: Mark optional fields as Optional with defaults",
            "**Validate early**: Catch structure errors before processing",
            "**Handle validation failures**: Always check validation_passed",
            "**Use nested models**: For complex structures, use nested Pydantic models"
          ]
        },
        {
          "title": "Common Mistakes",
          "type": "list",
          "items": [
            "❌ Not checking validation_passed before using validated output",
            "❌ Too strict constraints (rejecting valid responses)",
            "❌ Too loose constraints (accepting invalid structures)",
            "❌ Missing field descriptions (LLM doesn't understand what to extract)",
            "❌ Not handling optional fields properly"
          ]
        }
      ]
    }
  ]
}
